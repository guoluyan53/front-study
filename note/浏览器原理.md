![浏览器原理面试题.png](https://gitee.com/guoluyan53/image-bed/raw/master/img/1621608379974-5f496e1b-b721-4317-bd17-c3bb0411a510.png)

# 一、浏览器安全

# 二、进程与线程

# 三、浏览器缓存

# 四、浏览器组成

# 五、浏览器渲染原理

## 1. 浏览器渲染过程

1. 浏览器先对得到的HTML进行解析，之后进行网络资源的预处理，将以后要发送的请求提前加进请求队列中。
2. 浏览器将HTML转换为一个个的标记（标记化Tokenization），之后通过标记来构建DOM树；CSS同理，先进行标记化，再进行CSS样式树的构建。
3. 浏览器将DOM树和CSS样式树结合，生成渲染树。
4. 布局（回流）：浏览器根据渲染树，获取每个渲染树对象在屏幕上的位置和尺寸。
5. 绘制：将计算好的像素点绘制到屏幕
6. 渲染层合成：多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。

![img](https://gitee.com/guoluyan53/image-bed/raw/master/img/1603797939165-3bf54e28-5469-4093-a0e1-e0569cec1305.png)

> **注意**：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容 ，同时，可能还在通过网络下载其余内容。

## 2. 浏览器渲染优化

**（1）针对JavaScript**

JavaScript会阻塞HTML的解析，也会阻塞css的解析。

- <u>**尽量将JavaScript文件放在body的最后面**</u>
- **<u>body中间尽量不要写 `<script>`标签</u>**
- `<script>`标签的引入资源方式有三种，有一种就是常用的直接引入，还有两种就是使用 `async`属性和 `defer`属性来**异步引入**，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（**<u>尽量使用异步加载</u>**）。
  - **script**：立即停止渲染页面去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
  - **async**：是在下载完成之后，立即异步加载，加载好后立即执行，多个async属性的标签，不能保证加载的顺序
  - **defer**：是在下载完成之后，立即异步加载。加载好后，如果DOM树还没构建好，则先等待DOM树解析好后再执行；如果DOM树已经准备好，则立即执行。多个带defer属性标签，按照顺序执行。

**（2）针对CSS**

- <u>**导入外部样式使用link，而不用@import。**</u>
- <u>**如果css少，尽可能采用内嵌样式，直接写在style标签中。**</u>

一般使用css有三种方式：使用 **link、@import、内联样式**，其中link和@import都是导入外部样式。区别如下：

- **link**：浏览器会派发一个新的线程（HTTP线程）去加载资源文件，与此同时GIUI渲染线程会继续向下渲染代码
- **@import**：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染（阻碍浏览器渲染）。
- **style**：GUI直接渲染

> 外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器的默认样式，确保首次渲染的速度。所以CSS一般写在header中，让浏览器尽快发请求去获取CSS样式。

**（3）针对DOM树、CSSOM树**

- HTML文件的代码层级尽量不要太深
- 使用语义化的标签，来避免不标准语义化的特殊处理
- 减少CSSD代码的层次，因为选择器是从左向右进行解析的。

**（4）减少回流与重绘**

**渲染队列**：浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次回流、重绘变成一次回流重绘。

- 操作DOM时，尽量在低层级的DOM节点进行操作
- 不要使用table布局
- 使用CSS的表达式
- 不要频繁的操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- 使用absolute或fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。
- 将元素设置 `display:none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行DOM操作不会引发回流和重绘。
- 使用CSS3中的 `transform，opacity，filters`属性，启动GPU加速，这些属性的改变不会引发回流或重绘。

## 3. 什么是文档的预解析？

Webkit 和 Firefox都做了这个优化，当执行JavaScript脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。

需要注意的是，预解析并不改变DOM树，它将这个工作留给主解析过程，自己只解析外部资源引用，比如外部脚本、样式表以及图片。

## 4. css如何阻塞文档解析？

理论上，既然样式表不改变DOM树，也就没有必要停下文档的解析等待他们。然而，存在一个问题，JavaScript脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟JavaScript脚本执行和文档的解析，直到其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后再继续文档的解析。



# 六、浏览器本地存储

## 1. 浏览器本地存储方式以及使用场景

### ① Cookie  4KB

Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4KB，它是一种纯文本文件，每次发起http请求都会携带Cookie

**Cookie的特性**：

- Cookie一旦创建成功，名称就无法修改
- **Cookie是无法跨域名的**，也就是说a域名和b域名下的Cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样能够阻止非法获取其他网站的Cookie。
- 每个域名下的Cookie的数量不能超过20个，每个Cookie的大小不超过4kb
- 有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补。
- Cookie在请求一个新的页面的时候都会被发送过去。

**如果需要域名之间跨域共享Cookie，有两种方法**：

1. 使用Nginx代理
2. 在一个站点登录之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储SessionId。

**Cookie的使用场景**：

- 最常见的使用场景就是cookie和session结合使用，我们将sessionId存储到Cookie中，每次发送请求都会携带这个sessionId，这样服务器就知道是谁发起的请求，从而响应相应的信息。
- 可以用来统计页面的点击次数。

### ② LocalStorage  5M

**LocalStorage是html5新引入的特性**，由于有时候存储的信息量较大，Cookie就不能满足我们的需求，这时候LocalStorage就可以使用了。

**优点**：

- 大小一般为5M，可以存储更多的信息
- 是**持久性存储**，并不会随着页面的关闭而消失，除非主动清除，不然会永久存在。
- **仅存储在本地**，不像Cookie那样每次HTTP请求都会被携带

**缺点**：

- 存在浏览器兼容问题，IE8以下版本的浏览器不支持
- 如果浏览器设置为隐私模式，那么我们将无法读取LocalStorage
- LocalStorage**受到同源策略的限制**，即端口、协议、主机地址有任何一个不相同，都不会访问。

**LocalStorage常用API**：

```javascript
//保存数据到LocalStorage
LocalStorage.setItem('key','value');
//从localStorage获取数据
let data = localStorage.getItem('key');
//从LocalStorage删除保存的数据
localStorage.removeItem('key');
//从localStorage删除所有保存的数据
localStorage.clear();
//获取某个索引的key
localStorage.key(index)
```

**使用场景**：

- 有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可。
- 在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中

### ③ SessionStorage  5M

也是HTML5提出来的存储方案，sessionStorage主要用于**临时保存**同一窗口（或标签页）的数据，刷新页面是不会删除，关闭窗口或标签页之后将会删除这些数据。

**SessionStorage和LocalStorage对比**：

- SessionStorage和LocalStorage都在**本地进行数据存储**
- SessionStorage也有同源策略的限制，但是SessionStorage **只有在同一浏览器的同一窗口下才能够共享**；
- 两者都不能被爬虫爬取。

**SessionStorage的常用API**：

```javascript
// 保存数据到 sessionStorage
sessionStorage.setItem('key', 'value');
// 从 sessionStorage 获取数据
let data = sessionStorage.getItem('key');
// 从 sessionStorage 删除保存的数据
sessionStorage.removeItem('key');
// 从 sessionStorage 删除所有保存的数据
sessionStorage.clear();
// 获取某个索引的Key
sessionStorage.key(index)
```

**使用场景**：

由于sessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有**临时**的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。

## 2. cookie有哪些字段？

- **Name**：名称
- **Value**：值，对于认证cookie，value值包括web服务器所提供的访问令牌
- **Size**：大小
- **Path**：可以访问cookie的页面路径
- **Secure**：指定是否使用HTTPs安全协议发送Cookie。
- **Domain**:可以访问该cookie的域名，cookie机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的Cookie。
- **HTTP**：该字段包含`HTTPOnly` 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。
- **Expires/Max-size**：此cookie的超时时间。

**总结**：

服务端可以使用 **Set-Cookie** 的响应头部来配置 cookie信息。一条cookie包括了5个属性值 **expires**、**domain**、**path**、**secure**、**httpOnly**。

- **Expires**：指定cookie的失效时间
- **domain和path**：限制cookie能够哪些url访问。
- **secure**：规定了Cookie只能在确保安全的情况下传输。
- **httpOnly**：规定这个cookie只能被服务器访问，不能使用js脚本访问

## 3. 前端存储的方式有哪些？

- **Cookie**：由服务器设置，在客户端存储
- **localStorage**：永久性存储，在本地存储
- **SessionStorage**：临时存储，在本地存储
- **Web SQL**：2010年被W3C废弃的本地数据库存储方案。
- **IndexedDB**：是被正式纳入HTML5标准的数据库存储方案，它是NoSQL数据库，用键值对进行存储，可以进行快速读取操作，非常适合web场景，同时用JavaScript进行操作会非常方便。

# 七、浏览器同源策略

# 八、浏览器事件机制

# 九、浏览垃圾回收机制

