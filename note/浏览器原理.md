[TOC]

![浏览器原理面试题.png](https://gitee.com/guoluyan53/image-bed/raw/master/img/1621608379974-5f496e1b-b721-4317-bd17-c3bb0411a510.png)

# 一、浏览器安全

## 1. 什么是XSS攻击？

**（1）概念**

**XSS攻击指的是跨站脚本攻击，是一种代码注入攻击**。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如cookie等。

XSS的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了 ，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

攻击者可以通过这种攻击方式进行以下操作：

- 获取页面的数据，如DOM、cookie、localStorage
- DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器
- 破坏页面结构
- 流量劫持（将链接指向某网站）

**（2）攻击类型**

XSS可以分为存储型、反射型和DOM型：

- 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回执行。
- 反射型指的是攻击者诱导用户访问一个带有恶意代码的URL后，服务器端接收数据后处理，然后把带有恶意的代码的数据发送到浏览器端，浏览器端解析这段带有XSS代码的数据后当做脚本执行，最终完成XSS攻击
- DOM型指的通过修改页面的DOM节点形成XSS。

**（3）如何防御XSS攻击**？

- 可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到HTML中的代码做好充分的转义。对于DOM型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
- 使用CSP（内容安全策略），CSP的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
- 对一些敏感信息进行保护，比如cookie使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。

## 2. 什么是CSRF攻击？

**（1）概念**

CSRF攻击指的是 **跨站请求伪造攻击**，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

CSRF攻击的 **本质是利用Cookie会在同源请求中携带发送给服务器的特点，以此来冒充用户**。

**（2）攻击类型**

- GET类型的CSRF攻击，比如在网站中的一个img标签里构建一个请求，当用户打开这个网站时就会自动发起提交
- POST类型的CSRF攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单
- 链接类型的CSRF攻击，比如在a标签的href属性里构建一个请求，然后诱导用户区点击。

**（3）如何防御CSRF攻击**

- **进行同源检测**。服务器根据http请求头中origin或者Referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。
- 使用CSRF Token 进行验证
- 对cookie进行双重验证
- 在设置cookie属性的时候设置 Samesite，限制cookie不能作为被第三方使用。

## 3. 什么是中间人攻击？如何防范中间人攻击？

中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容

# 二、进程与线程

# 三、浏览器缓存

# 四、浏览器组成

# 五、浏览器渲染原理

## 1. 浏览器渲染过程

1. 浏览器先对得到的HTML进行解析，之后进行网络资源的预处理，将以后要发送的请求提前加进请求队列中。
2. 浏览器将HTML转换为一个个的标记（标记化Tokenization），之后通过标记来构建DOM树；CSS同理，先进行标记化，再进行CSS样式树的构建。
3. 浏览器将DOM树和CSS样式树结合，生成渲染树。
4. 布局（回流）：浏览器根据渲染树，获取每个渲染树对象在屏幕上的位置和尺寸。
5. 绘制：将计算好的像素点绘制到屏幕
6. 渲染层合成：多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。

![img](https://gitee.com/guoluyan53/image-bed/raw/master/img/1603797939165-3bf54e28-5469-4093-a0e1-e0569cec1305.png)

> **注意**：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容 ，同时，可能还在通过网络下载其余内容。

## 2. 浏览器渲染优化

**（1）针对JavaScript**

JavaScript会阻塞HTML的解析，也会阻塞css的解析。

- <u>**尽量将JavaScript文件放在body的最后面**</u>
- **<u>body中间尽量不要写 `<script>`标签</u>**
- `<script>`标签的引入资源方式有三种，有一种就是常用的直接引入，还有两种就是使用 `async`属性和 `defer`属性来**异步引入**，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（**<u>尽量使用异步加载</u>**）。
  - **script**：立即停止渲染页面去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
  - **async**：是在下载完成之后，立即异步加载，加载好后立即执行，多个async属性的标签，不能保证加载的顺序
  - **defer**：是在下载完成之后，立即异步加载。加载好后，如果DOM树还没构建好，则先等待DOM树解析好后再执行；如果DOM树已经准备好，则立即执行。多个带defer属性标签，按照顺序执行。

**（2）针对CSS**

- <u>**导入外部样式使用link，而不用@import。**</u>
- <u>**如果css少，尽可能采用内嵌样式，直接写在style标签中。**</u>

一般使用css有三种方式：使用 **link、@import、内联样式**，其中link和@import都是导入外部样式。区别如下：

- **link**：浏览器会派发一个新的线程（HTTP线程）去加载资源文件，与此同时GIUI渲染线程会继续向下渲染代码
- **@import**：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染（阻碍浏览器渲染）。
- **style**：GUI直接渲染

> 外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器的默认样式，确保首次渲染的速度。所以CSS一般写在header中，让浏览器尽快发请求去获取CSS样式。

**（3）针对DOM树、CSSOM树**

- HTML文件的代码层级尽量不要太深
- 使用语义化的标签，来避免不标准语义化的特殊处理
- 减少CSSD代码的层次，因为选择器是从左向右进行解析的。

**（4）减少回流与重绘**

**渲染队列**：浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次回流、重绘变成一次回流重绘。

- 操作DOM时，尽量在低层级的DOM节点进行操作
- 不要使用table布局
- 使用CSS的表达式
- 不要频繁的操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- 使用absolute或fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。
- 将元素设置 `display:none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行DOM操作不会引发回流和重绘。
- 使用CSS3中的 `transform，opacity，filters`属性，启动GPU加速，这些属性的改变不会引发回流或重绘。

## 3. 什么是文档的预解析？

Webkit 和 Firefox都做了这个优化，当执行JavaScript脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。

需要注意的是，预解析并不改变DOM树，它将这个工作留给主解析过程，自己只解析外部资源引用，比如外部脚本、样式表以及图片。

## 4. css如何阻塞文档解析？

理论上，既然样式表不改变DOM树，也就没有必要停下文档的解析等待他们。然而，存在一个问题，JavaScript脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟JavaScript脚本执行和文档的解析，直到其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后再继续文档的解析。



# 六、浏览器本地存储

## 1. 浏览器本地存储方式以及使用场景

### ① Cookie  4KB

Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4KB，它是一种纯文本文件，每次发起http请求都会携带Cookie

**Cookie的特性**：

- Cookie一旦创建成功，名称就无法修改
- **Cookie是无法跨域名的**，也就是说a域名和b域名下的Cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样能够阻止非法获取其他网站的Cookie。
- 每个域名下的Cookie的数量不能超过20个，每个Cookie的大小不超过4kb
- 有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补。
- Cookie在请求一个新的页面的时候都会被发送过去。

**如果需要域名之间跨域共享Cookie，有两种方法**：

1. 使用Nginx代理
2. 在一个站点登录之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储SessionId。

**Cookie的使用场景**：

- 最常见的使用场景就是cookie和session结合使用，我们将sessionId存储到Cookie中，每次发送请求都会携带这个sessionId，这样服务器就知道是谁发起的请求，从而响应相应的信息。
- 可以用来统计页面的点击次数。

### ② LocalStorage  5M

**LocalStorage是html5新引入的特性**，由于有时候存储的信息量较大，Cookie就不能满足我们的需求，这时候LocalStorage就可以使用了。

**优点**：

- 大小一般为5M，可以存储更多的信息
- 是**持久性存储**，并不会随着页面的关闭而消失，除非主动清除，不然会永久存在。
- **仅存储在本地**，不像Cookie那样每次HTTP请求都会被携带

**缺点**：

- 存在浏览器兼容问题，IE8以下版本的浏览器不支持
- 如果浏览器设置为隐私模式，那么我们将无法读取LocalStorage
- LocalStorage**受到同源策略的限制**，即端口、协议、主机地址有任何一个不相同，都不会访问。

**LocalStorage常用API**：

```javascript
//保存数据到LocalStorage
LocalStorage.setItem('key','value');
//从localStorage获取数据
let data = localStorage.getItem('key');
//从LocalStorage删除保存的数据
localStorage.removeItem('key');
//从localStorage删除所有保存的数据
localStorage.clear();
//获取某个索引的key
localStorage.key(index)
```

**使用场景**：

- 有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可。
- 在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中

### ③ SessionStorage  5M

也是HTML5提出来的存储方案，sessionStorage主要用于**临时保存**同一窗口（或标签页）的数据，刷新页面是不会删除，关闭窗口或标签页之后将会删除这些数据。

**SessionStorage和LocalStorage对比**：

- SessionStorage和LocalStorage都在**本地进行数据存储**
- SessionStorage也有同源策略的限制，但是SessionStorage **只有在同一浏览器的同一窗口下才能够共享**；
- 两者都不能被爬虫爬取。

**SessionStorage的常用API**：

```javascript
// 保存数据到 sessionStorage
sessionStorage.setItem('key', 'value');
// 从 sessionStorage 获取数据
let data = sessionStorage.getItem('key');
// 从 sessionStorage 删除保存的数据
sessionStorage.removeItem('key');
// 从 sessionStorage 删除所有保存的数据
sessionStorage.clear();
// 获取某个索引的Key
sessionStorage.key(index)
```

**使用场景**：

由于sessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有**临时**的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。

## 2. cookie有哪些字段？

- **Name**：名称
- **Value**：值，对于认证cookie，value值包括web服务器所提供的访问令牌
- **Size**：大小
- **Path**：可以访问cookie的页面路径
- **Secure**：指定是否使用HTTPs安全协议发送Cookie。
- **Domain**:可以访问该cookie的域名，cookie机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的Cookie。
- **HTTP**：该字段包含`HTTPOnly` 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。
- **Expires/Max-size**：此cookie的超时时间。

**总结**：

服务端可以使用 **Set-Cookie** 的响应头部来配置 cookie信息。一条cookie包括了5个属性值 **expires**、**domain**、**path**、**secure**、**httpOnly**。

- **Expires**：指定cookie的失效时间
- **domain和path**：限制cookie能够哪些url访问。
- **secure**：规定了Cookie只能在确保安全的情况下传输。
- **httpOnly**：规定这个cookie只能被服务器访问，不能使用js脚本访问

## 3. 前端存储的方式有哪些？

- **Cookie**：由服务器设置，在客户端存储
- **localStorage**：永久性存储，在本地存储
- **SessionStorage**：临时存储，在本地存储
- **Web SQL**：2010年被W3C废弃的本地数据库存储方案。
- **IndexedDB**：是被正式纳入HTML5标准的数据库存储方案，它是NoSQL数据库，用键值对进行存储，可以进行快速读取操作，非常适合web场景，同时用JavaScript进行操作会非常方便。

# 七、浏览器同源策略

## 1. 什么是同源策略

跨域问题其实就是浏览器的同源策略引起的。

**同源**：指的是 协议（protocol）、端口（port）、域名（domain）必须一致。

**同源策略**：只有浏览器才受到同源策略的限制。即不同源的脚本在没有授权的情况下，不能读写对方的资源。比如我们打开了 `A.com`，之后又在没有许可的情况下向 `B.com`发送请求，通常这个请求是失败的。想要摆脱同源策略的限制，就要使用跨域的手段。

**同源策略主要限制了三个方面**：

- 当前域下的js脚本不能够访问其他域下的cookie、localStorage、indexDB。
- 在当前域下的js脚本不能操作访问其他域下的DOM
- 当前域下ajax无法发送跨域请求。

## 2. 如何解决跨域问题

> 最常用的是 CORS 和 反向代理

### CORS

> `CORS`（Cross-origin ResourceSharing）跨域资源共享机制，它使用额外的http头来告诉浏览器 让运行在一个origin（domain）上的web应用被准许访问来自不同源服务器上的指定资源。当一个资源从该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域http请求。

**CORS的关键是服务器，只要服务器实现了CORS请求，就可以跨源通信了**。

只需要后端在响应头设置 `Access-Control-Allow-Origin: *`，*表示任意origin，也可以指定Origin。

使用CORS时默认不发送Cookie，想要发送Cookie需要：

1. 设置 `Access-Control-Allow-Credentials:true`
2. 此时 `Access-Control-Allow-Origin`不能设置为*，必须指定Origin

浏览器将CORS分为 **简单请求**和 **非简单请求**：

简单请求不会触发CORS **预检请求**。

**简单请求**：

> 在简单请求中，在服务器内，至少需要设置字段 ：`Access-Control-Allow-Origin`

- 请求方法是：HEAD、GET、POST
- HTTP的头信息不超出以下几种字段：
  - Accept
  - Accept-Language
  - Content-Language
  - Last-Event-ID
  - Content-Type：只限制于三个值 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

<u>**若不满足以上条件，就属于非简单请求了**</u>

**（1）简单请求过程**：

对于简单请求，浏览器会直接发出CORS请求，它会在请求头信息中增加一个Origin字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Origin指定的域名在许可范围之内服务器返回的响应就会多出以下信息头：

```javascript
Access-Control-Allow-Origin: http://api.bob.com  // 和Orign一直
Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie
Access-Control-Expose-Headers: FooBar   // 指定返回其他字段的值
Content-Type: text/html; charset=utf-8   // 表示文档类型
```

如果Origin指定的域名不在许可范围之内，服务器会返回一个正常的http回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误时无法通过状态码识别，因为返回的状态码可能是200.

**（2）非简单请求**

非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，称为 **预检请求**。

预检请求使用的方法是 **OPTIONS**，表示这个请求是来询问的。他的头信息中包括以下字段：

- **Access-Control-Request-Origin**：表示请求来自哪个源。
- **Access-Control-Request-Method**：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。
- **Access-Control-Request-Headers**：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。

服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，服务器回应的CORS字段如下：

```javascript
Access-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址
Access-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法
Access-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段
Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie
Access-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒
```

如果返回的头信息中有 Access-Control-Allow-Origin这个字段就是允许跨域请求。

### JSONP

**jsonp**的原理就是利用 `<script>`标签没有跨域限制，通过 `<script>`标签src属性，发送带有callback参数的GET请求，服务端将接口返回的数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。

```javascript
<script>
    var script = document.createElement('script');
    script.type = 'text/javascript';
    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);
    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
```

服务端返回如下（返回时即执行全局函数）：

```javascript
handleCallback({"success": true, "user": "admin"})
```

**缺点**：仅支持get方法，不安全，可能会受到XSS攻击。

### postMessage 跨域

postMessage是HTML5 XMLHttpRequest Level2中的API。

用法： `postMessage(data,origin)`

```javascript
window.postMessage('message',url)
window.on('message',function(e){
    console.log(e.data)
})
```

### 反向代理

由于同源策略是浏览器的策略。

`A.com:80`不能向 `B.com:3000`发送请求。那么我们可以在 `A.com:8080`设置一个代理服务器来代理请求，之后发请求就是 `A.com:80 -> A.com:8080 ->B.com:3000`,此时请求可以成功发过去。

通常我们本地开发项目是使用 `webpack-dev-server`，而它自带了代理服务器的功能（只需要我们在配置文件中加上 `proxy`），所以可以轻松解决跨域问题。除此之外我们也可以使用 `nginx`来反向代理。

#### nginx代理跨域

nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin...等字段

**（1）nginx配置解决iconfont跨域**

浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件（eot|otf|ttf|woff|svg）例外，此时可在nginx的静态资源服务器中加入以下配置

```http
location / {
	add_header Access-Control-Allow-Origin *;
}
```

**（2）nginx反向代理接口跨域**

跨域问题：同源策略仅是针对浏览器的安全策略。服务器端用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。

实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。

```nginx
#proxy服务器
server {
    listen		81;
    server_name	www.domain1.com;
    location / {
        proxy_pass	http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;
        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

### document.domain

此方案仅限主域相同，子域不同的跨域应用场景。

实现原理：两个页面都通过JS强制设置document.domain为基础主域，就实现了同域。

Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置`document.domain`共享 Cookie。

如a.example.com和b.example.com。

**此时两个网站都设置 `document.domain = "example.com"`， 那么两个网页就可以共享Cookie了。**

```javascript
//a.example.com
document.cookie = 'aaa'
//b.examlpe.com
console.log(document.cookie) //'aaa'
```

### location.hash + iframe 跨域

**实现原理**：a欲与b跨域相互通信，通过中间页c来实现。三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js来访问

**具体实现**：A域（a.html)  ->  B域（b.html）-> A域（c.html）。a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以可以通过parent.parent访问a页面所有对象。

（1）a.html：（domain1.com/a.html)

```javascript
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');
    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);
    
    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>
```

（2）b.html：(.domain2.com/b.html)

```javascript
<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');
    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>
```

3）c.html：([http://www.domain1.com/c.html](https://link.zhihu.com/?target=http%3A//www.domain1.com/c.html))

```javascript
<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
```

### window.name

这个方法主要用于**父窗口和iframe窗口的通信**。

如果父窗口和iframe窗口是不同源的，则通常无法进行通信。

```html
<html>
    <body>
        <!-- 我是父窗口 -->
        <iframe src='xxx.com'>
            <!-- 我是子窗口 -->
        </iframe>
    </body>
</html>
```

`window.name`特点：无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。

例如，我们在a.com页面下设置

```js
window.name = '123'
location.href = 'b.com'
```

然后在b.com也能获取到`window.name`的值。

实现跨域：

使用时，先设置`iframe`的`src`为我们想要通信的目标页面。当目标页面的`window.name`修改时，将我们的`iframe`的`src`修改为一个和父窗口同源的页面。

本质：

iframe内的目标页面 <=> iframe内的一个和父窗口同源的页面 <=> 父窗口

## 3. 正向代理和反向代理的区别

**正向代理**

客户端想要获取一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真是服务器隐藏真实客户端的目的。**实现正向代理需要修改客户端，比如修改浏览器配置。**

**反向代理**

服务器为了能够将工作负载分发到多个服务器来提高网站性能（负载均衡）等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。

一般使用反向代理后，需要通过修改DNS让 域名解析到代理服务器IP，这时浏览器无法察觉到真正的服务器的存在吗，当然也就不需要修改配置了。

![img](https://gitee.com/guoluyan53/image-bed/raw/master/img/1605256274960-50bd9e69-dde9-4782-b2c0-6afc8188fca2.jpeg)

> 正向代理和反向代理的结构是一样的，都是client-proxy-server的结构，他们主要的区别就在于中间这个proxy是哪一方设置的。在正向代理中，proxy是client设置的，用来隐藏client；在反向代理中，proxy是server设置的，用来隐藏server。



# 八、浏览器事件机制

## 1. 事件是什么？事件模型？

**事件**是用户操作网页时发生的交互动作，比如click/move，事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个event对象，包含了该事件发生时的所有相关信息（event 的属性）以及可以对事件进行的操作（event方法）。

**事件是用户操作网页时发生的交互动作或者网页本身的一些操作**，现代浏览器一共有三种事件模型：

- **DOM 0级事件模型**，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过js属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0 写法。
- **IE 事件模型**，该事件模型中，一次事件共有两个过程，**事件处理**阶段和**事件冒泡**阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent来添加监听函数，可以添加多个监听函数，会按顺序依次执行。
- **DOM2级事件模型**，在该事件模型中，一次事件共有三个过程，第一个过程是**事件捕获**阶段。捕获指的是事件从document一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和IE事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。

## 2. 如何阻止事件冒泡

- 普通浏览器使用：`event.stopPropagation()`
- IE浏览器使用：`event.cancelBubble = true`

## 3. 对事件委托的理解

**（1）事件委托的概念**

事件委托本质上是利用了 **浏览器事件冒泡** 的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为**事件委托（事件代理）**。

使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。

**（2）事件委托的特点**

- 减少内存消耗
- 动态绑定事件

例子：如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件，我们可以把点击事件绑定在他的父级，也就是ul上。

```html 
<ul id="list">
    <li>item 1</li>
    <li>item 2</li>
    ...
    <li>item n</li>
</ul>
<script>
//给父层元素绑定事件
document.getElementById('list').addEventListener('click',function(e){
    //兼容性处理
    var event = e || window.event;
    var target = event.target || event.srcElement;
    //判断是否匹配目标元素
    if(target.nodeName.toLocaleLowerCase === 'li'){
        console.log('the content is:',target.innerHTML);
    }
})
</script>
```

在上述代码中，target元素则是在#list元素之下具体被点击的元素，然后通过判断target的一些属性（比如：nodeName，id等等）可以更精确地匹配到某一类#list li 元素之上。

**（3）事件委托的局限性**

focus、blur之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。

事件委托会影响页面的性能，主要影响因素有：

- 元素中，绑定事件委托的次数；
- 点击最底层的元素，到绑定事件元素之间的DOM层数

在必须使用事件委托的地方，可以进行如下处理：

- 只在必须的地方，使用事件委托，比如：ajax的局部刷新区域
- 尽量的减少绑定的层级，不在body元素上进行绑定
- 减少绑定的次数，如果可以，那么把多个事件绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。

## 4. 同步和异步的区别

- **同步**指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。
- **异步**指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。



# 九、浏览垃圾回收机制

