![计算机网络面试题.png](https://gitee.com/guoluyan53/image-bed/raw/master/img/1621606395878-ec50f847-ec2c-451b-885a-0baac77777e0.png)

[TOC]

# 一、HTTP和HTTPS协议

## 1. get和post的区别

- **应用场景**：GET请求一般用于对服务器资源不会产生影响的场景。post一般用于对服务器产生影响的场景。
- **是否缓存**：浏览器一般会对get请求缓存，很少对post请求缓存
- **发送的报文格式**：get请求的报文中实体部分为空，post请求的报文实体部分一般为向服务器发送的数据。
- **安全性**：post比get相对安全
- **请求长度**：浏览器由于对url长度的限制，会影响get请求发送数据时的长度。
- **参数类型**：post的参数传递支持更多的数据类型。

## 2. 常见的HTTP请求头和响应头

**HTTP Request Header常见的请求头**：

```http
Accept: 浏览器能够处理的内容类型
Accept-Charset: 浏览器能够显示的字符集
Accept-Encoding: 浏览器能够处理的压缩编码
Accept-Language: 浏览器当前设置的语言
Connection: 浏览器与服务器之间的连接类型
Cookie: 当前页面设置的任何Cookie
Host: 发出请求的页面所在域
Referer: 发出请求的页面的URL
User-Agent: 浏览器用户代理字符串
```

**HTTP Responses Header 常见的响应头**：

```http
Date: 表示消息发送的时间，时间的描述格式由rfc822定义
server: 服务器名称
Connection: 浏览器与服务器之间连接的类型
Cache-Control: 控制http缓存
content-type: 表示后面的文档属于什么MIME类型
```

## 3. 讲讲304 

304 ：如果客户端发送了一个带条件的get请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304 状态码。

通俗来说就是：服务器为了提高网站的访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，在此客户端调用缓存内容，不必进行二次下载。

状态码304不应该认为是一种错误，而是对客户端 **有缓存情况下** 服务端的一种响应。

**产生较多304状态码的原因**：

- 页面更新周期长或不更新
- 纯静态页面或强制生成静态HTML

**304状态码出现过多会造成以下问题**：

- 网站快照停止
- 收录减少
- 权重下降

## 4. 说一下http和https

> https 的 SSL加密是在传输层实现的。

### **（1）http和https的基本概念**

`http`：超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

`https`：是以安全为目标的HTTP通道，简单讲是http的安全版，即http下加入SSL层，https的安全基础是SSL，因此加密的详细内容就需要SSL。https协议的主要作用是，建立一个信息安全通道，来确保数组的传输，确保网站的真实性。

### **（2）http 和 https的区别**

http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https是由http和SSL协议构建的可进行加密传输和身份认证的网络协议，比http的安全性更高。

- https协议需要ca证书，费用较高
- http协议是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议
- 使用不同的连接方式，端口也不同，http端口是80，https端口是443
- http的连接很简单，是无状态的；https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，比http安全。

### （3）https工作原理

1. 客户端使用https url 访问服务器，则要求web服务器建立ssl连接
2. web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。
3. 客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级
4. 客户端浏览器通过双方协商一致的安全等级，建立会话秘钥，然后通过网站的公钥来加密会话秘钥，并传送给网站。
5. web服务器通过自己的私钥解密出会话秘钥
6. web服务器通过会话秘钥加密与客户端之间的通信

## 5. HTTP1.0 ，1.1， 2.0

### HTTP1.0比较1.1

- **连接方面**：http1.0默认使用非持久连接，http1.1默认使用持久连接。http1.1通过使用持久连接来使多个http请求复用同一个TCP连接，以此来避免使用非持久连接时每次需要建立连接的时延。
- **资源请求方面**：http1.0存在带宽浪费现象，比如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点功能。http1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206，便于充分利用带宽和连接。
- **缓存方面**：在http1.0中主要使用 header里的 `if-Modified-Since`、`Expires`来作为缓存判断标准，在http1.1则引入了更对的缓存控制策略，例如 `Etag`、`If-Unmodified-Since`、`If-Match`、`If-None-Match`等更多可供选择的缓存头来控制缓存策略。
- http1.0不支持Host头部，Http1.1支持，可以实现虚拟主机
- http1.1新增了很多的请求方法，如PUT、HEAD。还新增了24个错误状态响应码，如409（conflict）表示请求的资源与资源当前状态发生冲突。

### HTTP1.1比较2.0

- **二进制协议**：HTTP2.0是一个二进制协议。在http1.1中，报文的头信息必须是文本（ASCLL编码），数据体可以是文本，也可以是二进制。HTTP2则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”，可以分为头信息帧和数据帧。
- **多路复用**：http2实现了多路复用，http2仍然复用TCP连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送。就是说在同一时间里可以发送多个请求。
- **头部信息压缩**：对报文的头部进行压缩，在客户端和服务器端都维护着一份字典记录着头部对应的索引。
- **服务器推送**：HTTP2允许服务器未经请求，主动向客户端发送资源，这叫服务器推送。推送的是静态资源。

## 6. HTTP状态码

**状态码的类别**：

| 类别 | 原因                             | 描述                        |
| ---- | -------------------------------- | --------------------------- |
| 1XX  | Informational（信息性状态码）    | 接收的请求正在处理          |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕            |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作---完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求          |
| 5XX  | Server Error（服务器错误状态码） | 服务器请求出现错误          |

### （1）1XX  通知

- 100 Continue 客户端重新发请求
- 101 更改协议 http，https，http1.0,1.1，2.0

### （2）2XX  Success 成功状态码

- **200 OK 请求成功。一般用于GET与POST请求**
- **201 Created 已创建。成功请求并创建了新资源**
- **202 Accepted 已接受。已经接收请求，但未处理完成**
- **204 No Content 无内容。但是报文不含实体的主体部分**
- **205 Reset Content 重置内容。服务器处理成功，用户终端应重置文档视图**
- 206 Partial Content 部分内容。服务器成功处理了部分GET请求

### （3）3XX  重定向状态码 

- 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用户终端选择
- **301 Moved Permanently 永久性重定向（移动）**
- **302 Found 临时重定向（移动）**
- **303 See Other 查看其它地址。资源存在另一个URL**
- **304 Not Modified 未修改。允许访问资源，但你实体为空**
- 305 Use Proxy 使用代理。
- 306 Unused 已经被废弃的HTTP状态码
- 307 Temporary Redirect 临时重定向

### （4）4XX  客户端错误状态码

- **400 Bad Request 请求报文语法错误**
- **401 Unauthorized 请求要求用户的身份认证**
- **402 Payment Required 保留，将来使用**
- **404 Not Found 找不到资源**
- **405 Method Not Allowed 不支持的请求方法**

### （5）5XX 服务器端错误状态码

- 500 Internal server error  服务器在执行请求时发生了错误
- 501 Not Implemented  服务器不支持请求的方法
- 502 Bad Gateway （代理服务器与上行服务器出现问题）作为网关或者代理工作的服务器执行请求时，从远程服务器接收到了一个无效的响应。
- 503 Service unavailable 服务器暂时超负荷或正在停机处理，无法处理请求

# 二、DNS协议

## 1. DNS协议是什么？

DNS（Domain Name System）是域名系统的缩写，**提供一种主机名到IP地址的转换服务**。它是由一个分层的DNS服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够方便人访问互联网，而不用去记住能够被机器直接读取的IP数串。

**作用**：将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的IP地址。

## 2. DNS同时使用TCP和UDP协议？

**DNS占用53端口，同时使用TCP和UDP协议**。

（1）在区域传输的时候使用TCP协议

- 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如果有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
- TCP是一种可靠连接，保证了数据的准确性。

（2）在域名解析的时候使用UDP协议

- 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询。

## 3. DNS完整的查询过程

**DNS服务器解析域名的过程**：

- 首先会在**浏览器的缓存**中查找对应的IP地址，如果差查找到直接返回，若找不到继续下一步
- 将请求发送给 **本地DNS服务器**，在本地域名（DNS）服务器缓存中查询，如果查找到直接将结果返回，若找不到继续下一步
- 本地域名服务器向 **根域名服务器** 发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
- 本地域名服务器向 **顶级域名服务器** 发送请求，接受请求的服务查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
- 本地域名服务器向**权限域名服务器**发送请求，域名服务器返回对应的结果
- 本地域名服务器将返回结果保存在缓存中，以便下一次使用
- 本地DNS服务器将返回结果返回给浏览器

## 4. 迭代查询和递归查询

实际上，DNS解析是一个包含迭代查询和递归查询的过程。

- **递归查询**指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。只用递归查询，用户只需要发出一次查询请求。
- **迭代查询**指的是查询请求后，域名服务器返回单次查询的结果。下一级查询由用户自己请求。使用迭代查询，用户需要发出多次的查询请求。

# 三、TCP与UDP

> TCP是传输控制协议，UDP是用户数据报协议。都是基于传输层的通信协议。

## 1. TCP和UDP的区别

1. TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接。
2. TCP提供可靠的服务，也就是说，提供TCP连接的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。
3. TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低
4. TCP只能是一对一，UDP支持1对1,1对多，多对多
5. TCP是面向连接的可靠传输，UDP是不可靠的。
6. TCP头部较大为20字节，而UDP只有8字节。

## 2. TCP的三次握手和四次挥手

![img](https://gitee.com/guoluyan53/image-bed/raw/master/img/1604023663256-5eb6dcdf-fdb6-4b67-a3da-da15c1d396fb.png)

### 三次握手

三次握手其实就是指建立一个TCP连接，需要客户端和服务器总共发送3个包。进行三次握手的主要作用是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

**刚开始客户端处于closed的状态，服务端处于listen状态**：

（1）**第一次握手**：客户端给服务器发送一个SYN报文，服务器知道自己可以接收到客户端发送的报文

`该报文的SYN=1，初始序号seq=x。`（SYN=1的报文段不能携带数据，但要消耗一个序号）

（2）**第二次握手**：服务器向客户端发送**报文**，客户端知道自己可以接收服务端发送的报文，知道自己发送的报文能被服务端接收。

`该报文的SYN = 1，ACK=1，确认号ack = x+1, 初始序号 seq = y。`

（3）**第三次握手**：客户端给服务端发送报文，服务端知道自己发送的报文能被客户端接收。此时，客户端处于Establish状态，服务端收到ACK报文后，也处于establish状态，此时，双方已经建立了连接。

`该报文的ACK=1，确认号ack=y+1，序号seq=x+1`（初始为seq=x，第二个报文段所以要+1，这个是针对客户端来说的）ACK报文段可以携带数据，不懈怠数据则不消耗序号。

> 注：SYN / ACK / FIN 为TCP报文头部的一个标识，seq为报文的序列号,ack为报文的确认号（并不是ACK）。
>
> SYN = 1，seq = x对应的是ACK = 1，ack = x+1。
>
> - `SYN`：同步位。发送连接请求或连接请求确认时才为1，其余状态为0。
> - `seq`：序号位，刚开始发送时随机的
> - `ACK`：确认位。
> - `ack`：确认号。ack = seq（上一个报文信息的seq）+1 。是同一端发出的哦。







# 四、网络模型

# 五、WebSocket
