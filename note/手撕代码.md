## 1. call、apply、bind的实现

### 实现call

1.不传入第一个参数时，默认为window

2.改变了 this 指向，让新的对象可以执行该函数（给新对象添加一个函数，执行完之后删除）

```javascript
Function.prototype.myCall=function(context, ...args){
    if(typeof this !=='function'){
        throw new TypeError('error');
    }
    var context=context||window;
    context.fn=this;
    //getValue.call(a,'xxx','xxx')=>a.fn('xxx','xxx')
    var result=context.fn(...args);
    delete context.fn;
    return dalete;
}
```

### 实现Apply

```javascript
//思路一致
Function.prototype.apply()=function(context, args = []){
    if(typeof this !=='function'){
        throw new TypeError('error');
    }
    context=context||window;
    context.fn=this;
    let result;
    //参数处理有区别,第二个参数是一个数组
    result=context.fn(...args);
    delete context.fn;
    return result;
}
```

### 实现Bind

因为bind返回的是一个函数，所以需要判断边界，复杂一些。

```javascript
Function.prototype.myBind=function(context){
	if (typeof this !== 'function') {
    	throw new TypeError('error');
    }
    const _this=this;
    const args=[...arguments].slice(1);
    return function F(){
        // new 函数，不动this
        if (this instanceof F){
            return new _this(...args,...arguments);
        }
        return _this.apply(context,args.concat(...arguments));
    }
}
```

- bind返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new的方式，我们先来说直接调用的方式
- 对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind可以实现类似这样的代码 `f.bind(obj, 1)(2)`，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 `args.concat(...arguments)`
- 对于 `new` 的情况来说，不会被任何方式改变 `this`，所以对于这种情况我们需要忽略传入的 `this`

