[TOC]

## 1. call、apply、bind的实现

### 实现call

1. 判断调用对象是否为函数，即 使我们是定义在函数的原型上的，但是可能出现使用call等方式调用的情况。
2. 判断传入的上下文对象是否存在，如果不存在，则设置为window
3. 处理传入的参数，截取第一个参数后的所有参数
4. 将函数作为上下文对象的一个属性。
5.  使用上下文对象来调用这个方法，并保存返回结果
6. 删除刚才新增的属性
7. 返回结果

```javascript
Function.prototype.myCall = function(context){
    //判断调用对象
    if(typeof this != "function"){
        console.error("type error");
    }
    //获取参数
    let args = [...arguments].slice(1),
        result = null;
    //判断 context是否传入，如果未传入则设置为window
    context = context || window;
    //将调用函数设置为对象的方法
    context.fn = this;
    //调用函数
    result = context.fn(...args);
    //	将属性删除
    delete context.fn;
    return result;
};
```

### 实现Apply

第二个参数传入的是一个数组形式：

```javascript
// apply 函数实现
Function.prototype.myApply = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  let result = null;
  // 判断 context 是否存在，如果未传入则为 window
  context = context || window;
  // 将函数设为对象的方法
  context.fn = this;
  // 调用方法
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  // 将属性删除
  delete context.fn;
  return result;
};
```

### 实现Bind

因为bind返回的是一个函数，所以需要判断边界，复杂一些。

1. 判断调用对象是否为函数
2. 保存当前函数的应用，获取其余传入参数值
3. 创建一个函数返回
4. 函数内部使用apply来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的this给apply调用，其余情况都传入指定上下文对象。

```javascript
// bind 函数实现
Function.prototype.myBind = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  // 获取参数
  var args = [...arguments].slice(1),
      fn = this;
  return function Fn() {
    // 根据调用方式，传入不同绑定值
    return fn.apply(
      this instanceof Fn ? this : context,
      args.concat(...arguments)
    );
  };
};
```

- bind返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new的方式，我们先来说直接调用的方式
- 对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind可以实现类似这样的代码 `f.bind(obj, 1)(2)`，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 `args.concat(...arguments)`
- 对于 `new` 的情况来说，不会被任何方式改变 `this`，所以对于这种情况我们需要忽略传入的 `this`

## 2. 手撕instanceof方法

instanceof运算符用于判断构造函数的prototype属性是否出现在对象的原型链中的任何位置。

实现步骤：

1. 首先获取类型的原型
2. 然后获得对象的原型
3. 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为null，因为原型链最终为null

```javascript
function myInstanceof(obj,newobj){
    let proto = Object.getPrototypeOf(obj); //获取对象的原型
    let prototype = newobj.prototype; //获取构造函数的原型
    //判断构造函数的prototype是否在对象的原型链上
    while(true){
        if(!proto) return false;
        if(proto === prototype) return true;
        proto = Object.getPrototype(proto);
    }
}
```

> 使用的方法：`Object.getPrototypeOf()`获取对象的原型

## 3. 手撕 Object.create

`Object.create()` 方法会使用指定的原型对象及其属性去创建一个新的对象。

将传入的对象作为原型。

```javascript
function create(obj){
    function F(){};
    F.prototype = obj;
    return new F();
}
```



## 4. 手撕new操作符

在调用new的时候会发生四件事：

1. 首先创建一个新的空对象
2. 设置原型，将对象的原型设置为构造函数的prototype对象
3. 让函数的this指向这个对象，执行构造函数的代码（为这个对象添加新属性）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

```javascript
function myNew(){
    let newObject = null;  //创建一个空对象
    let constructor = Array.prototype.shift.call(arguments); //获取传入的第一个参数
    let result = null;
    //判断参数是否是一个函数
    if(typeof constructor !== "function"){
        console.error("type error");
        return;
    }
    //创建一个空对象，对象的原型为构造函数的prototype对象
    newObject = Object.create(constructor.prototype);
    //将this指向新建对象，并执行函数
    result = constructor.apply(newObject,arguments);
    //判断返回对象
    let flag = result && (typeof result === "object" || typeof result === "function");
    //判断返回结果
    return flag ? result : newObject;
}
//使用方法
myNew(构造函数，初始化参数)
```

## 5. 防抖和节流

### 防抖

函数防抖是指在事件被触发n秒后再执行回调函数，如果在这n秒内事件又被触发，则重新计时。即以最后一次执行为倒计时。这可以使用在一些点击请求上，避免因为用户的多次点击向后端发送多次请求。

```javascript
function debounce(fn,wait){
    let timer = null;  //计时
    return function(){
        let context = this;
        let args = arguments;
        //如果此时存在计时器，则清空计时重新计时
        if(timer){
            clearTimeout(timer);
            timer = null;
        }
        //重新设置定时器
        timer = setTimeout(()=>{
            fn.apply(context,args);
        },wait);
    };
}
```

### 节流

函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只能有一次生效。节流可以使用在scroll函数的事件监听上，通过事件节流来降低事件调用的频率。

```javascript
function throttle(fn,delay){
    let curTime = Date.now();
    return function(){
        let context = this,
            args = arguments,
            nowTime = Date.now();
        //如果两次时间间隔超过了指定时间，则执行函数
        if(nowTime - curTime >= delay){
            curTime = Date.now();
            return fn.apply(context,args);
        }
    };
}
```

## 6. 函数柯里化的实现

**[一文理解函数柯里化](https://juejin.cn/post/6844903882208837645)**

函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。**柯里化的用途可以被理解为：参数复用**

对于柯里化的实现，我们只需要接收一部分参数，返回一个函数接收剩余参数，接收足够参数后，执行原函数。

```javascript
function curry(fn,args){
    //获取函数需要的参数长度
    let length = fn.length;
    args = args || [];
    return function(){
        let subArgs = args.slice(0);
        //拼接得到现有的所有参数
        for(let i=0; i<arguments.length;i++){
            subArgs.push(arguments[i]);
        }
        //判断参数的长度是否已经满足函数所需参数的长度
        if(subArgs.length >= length){
            //如果满足，执行函数
            return fn.apply(this,subArgs);
        }else{
            //如果不满足，递归返回柯里化的函数，等待参数的传入
            return curry.call(this,fn,subArgs);
        }
    };
}

//es6实现
function curry(fn,...args){
    return fn.length <= args.length ? fn(...args) : curry.bind(null,fn,args);
}
```

- 通过**函数的length属性**，获取函数的参数个数，形参的个数就是所需的参数个数。

## 7. 手撕Ajax

**[理解ajax](https://juejin.cn/post/6938290463669485581)**

**[个人博客笔记](https://sandystar.xyz/2021/11/16/JavaScript/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8BPromise/)**

Ajax（Asynchronous JavaScript and XML）指的是通过JavaScript的异步通信，从服务器获得XML文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。

### 创建ajax请求的步骤：

1. **创建一个XMLHTTPRequest对象**
2. 在这个对象上 **使用open方法创建一个HTTP请求**，open方法所需要的参数是请求的方法，请求的地址、是否异步和用户的认证信息。
3. 在发起请求之前，可以为这个对象 **添加一些请求信息和监听函数**。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个XMLHttpRequest对象一共5个状态，当它的状态变化时会触发`onreadystatechange`事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的readyState 变为4的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是2XX或者304的话则代表返回正常。这个时候就可以通过response中的数据来对页面进行更新了。
4. 当对象的属性和监听函数设置完成后，最后调用 **send方法来向服务器发起请求**，可以传入参数作为发送的数据体。

```javascript
const SERVER_URL = 'http://abc.com';
let xhr = new XMLHttpRequest();
//创建http请求
xhr.open("GET",SERVER_URL,true);
//设置状态监听函数
xhr.onreadystatechange = function(){
    if(this.readyState !==4) return;
    //当请求成功时
    if(this.status === 200){
        handle(this,response);
    }else{
        console.error(this.statusText);
    }
};
//设置请求失败时的监听函数
xhr.onerror = function(){
    console.error(this.statusText);
}
//设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept","application/json");
//发送http请求
xhr.send(null);
```

### 封装一个ajax函数

```javascript
/*
参数1：{string} method 请求方法
参数2：{string} url    请求地址
参数3：{object} params 请求参数
参数4：{function} done 请求完成后执行的回调函数
*/
function ajax(method,url,params,done){
    //创建xhr对象，兼容写法
    var xhr = window.XMLHttpRequest ? new XMLHttpRequest : new ActiveXObject("Microsoft.XMLHTTP");
    //将method转换为大写
    method = method.toUpperCase();
    //参数拼接
    var pair = [];
    for(let key in params){
        pair.push(key + "=" + params[key]);
    }
    var str = pair.join("&");
    //判断请求方法
    if(method === "GET"){
        url += "?" + str;
    }
    xhr.open(method,url);
    var data = null;
    if(method === "POST"){
        //需要请求头
        xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
        data = str;
    }
    xhr.send(data);
    //指定xhr状态变化事件处理函数
    //执行回调函数
    xhr.onreadystatechange = function(){
        if(this.readyState === 4 && this.state===200){
            //返回的应该是一个对象，这样客户端更好渲染
            done(JSON.parse(xhr.responseText));
        }
    }
}
//调用自己写的ajax哈数
ajax("get","http://abc.com",{
    name:'zz',
    age:10
},function(a){
    console.log(a);
})
```

### 用promise封装ajax

```javascript
function sendAjax(url) {
    return Promise((resolve,reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open("GET",url);
        xhr.send();
        //处理结果
        xhr.onreadystatechange = function(){
            if(xhr.readyState === 4){
                if(xhr.status >= 200 && xhr.status <300) {
                    //成功的结果为响应体response
                    resolve(xhr.response);
                }else {
                    reject(xhr.status);  //失败放响应码
                }
            }
        }
    });
}
//调用
sendAjax('https://api.apiopen.top/getJoke')
.then((value)=> {
    console.log(value);
},(reason)=> {
    console.warn(reason);
});
```

