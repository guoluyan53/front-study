> [参考文章](https://www.cnblogs.com/AlbertP/p/10847627.html)

# 十大排序算法对比

![img](https://gitee.com/guoluyan53/image-bed/raw/master/img/1867034-1d3e43cdb301fc9b.png)

- **n**：数据规模
- **K**：“桶”的个数
- **In-place**：占用常数内存，不占用额外内存
- **Out-place**：占用额外内存
- **稳定性**：排序后2个相等键值的顺序和排序之前它们的顺序相同

# 1. 冒泡排序（Bubble sort）

> 思想：有多少个元素就遍历多少趟，并且每趟都要两两比较相邻的元素。
>
> 时间复杂度：O(n^2)

**（1）什么时候最快？**

当输入数据已经是正序的时候

**（2）什么时候最慢？**

当输入数据是反序的时候

**动画演示**：

![img](https://gitee.com/guoluyan53/image-bed/raw/master/img/1867034-e19840224b331fae.gif)

```javascript
function BubbleSort(arr){
    let len = arr.length;
    for(let i=0;i<len;i++){
        for(let j=0;j<len-1-i;j++){
            if(arr[j]>arr[j+1]){  //相邻元素两两对比
                temp = arr[j+1];   //元素交换
                arr[j+1] = a[j];
                a[j] = temp;
            }
        }
    }
    return arr;
}
```

# 2. 选择排序（Selection Sort）

> 思想：每趟遍历选择最小或最大的元素，将它放到遍历次数的相应位置。
>
> 时间复杂度：O(n^2)

使用的数据规模越小越好

**动画演示**：

![img](https://gitee.com/guoluyan53/image-bed/raw/master/img/1867034-c6cc220cfb2b9ac8.gif)

```javascript
function selectionSort(arr){
    let len = arr.length;
    let minIndex,temp;
    for(let i=0;i<len;i++){
        minIndex = i;
        for(let j=i+1;j<len;j++){
            if(arr[j]<arr[minIndex]){ //寻找最小的数
                minIndex = j;  //将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
```

# 3. 插入排序（Insertion Sort）

> 思想：插入排序的思想有点类似于整理扑克牌。就是选择当前元素，看看在当前元素的前面有没有适合自己的位置插入。适合就插入，不适合就还是放在原地。
>
> 时间复杂度：O(n^2)

插入排序有种优化算法：拆半插入。

**动画演示**：

![img](https://gitee.com/guoluyan53/image-bed/raw/master/img/1867034-d1537e355abdd298.gif)

```javascript
function insertSort(arr){
    let len = arr.length;
    let preIndex,cur;
    for(let i=1;i<len;i++){
        preIndex = i-1;
        cur = arr[i];
        while(preIndex>=0 && arr[preIndex] > cur){
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = cur;
    }
    return arr;
}
```

# 4. 希尔排序（Shell sort）

> 希尔排序是插入排序的一种更高效的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。
>
> 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔排序，也可以动态的定义间隔序列。

![image-20211012211914809](https://gitee.com/guoluyan53/image-bed/raw/master/img/Srk5IvV1YtufZbE.png)

```javascript
function shellSort(arr) {
    let len = arr.length;
    let temp,gap = 1;
    while(gap < len/3){   //动态定义间隔序列
        gap = gap*3+1;
    }
    for(gap; gap>0;gap = Math.floor(gap/3)){
        for(let i=gap; i<len; i++){
            temp = arr[i];
            for(var j=i-gap; j>=0 && arr[j] > temp;j-=gap){
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    return arr;
}
```

# 5. 归并排序（Merge Sort）

> 典型的分而治之算法，归并排序的实现有两种方法：
>
> 1. 自上而下递归
> 2. 自下而上的迭代
>
> **O(n log n）的时间复杂度**。需要额外的内存空间。

**分治模式在每一层递归上有三个步骤**：

- **分解（Divide）**：将n个元素分成含 n/2 个元素的子序列
- **解决（Conquer）**：用合并排序法对两个子序列递归的排序。
- **合并（Combine）**：合并两个已排序的子序列已得到排序的结果。

**动画演示**：

![img](https://gitee.com/guoluyan53/image-bed/raw/master/img/1867034-18c70f637b5c01c2.gif)

```javascript
function mergeSort(arr) { //采用自上而下的递归方法
    let len = arr.length;
    if(len <2){
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0,middle),
        right = arr.slice(middle);
    return merge(mergeSort(left),mergeSort(right));
}

function merge(left,right){
    var res = [];
    while(left.length && right.length) {
        if(left[0] <= right[0]){
            res.push(left.shift());  //放入第一个元素
        }else{
            res.push(right.shift());
        }
    }
    
    while(left.length){
        res.push(left.shift());
    }
    while(right.length){
        res.push(right.shift());
    }
    return res;
}
```

# 6. 快速排序（Quick Sort）

> 是一种分而治之的思想。快速排序应该算是在冒泡排序基础上的递归分治法。

**步骤**：

- 快速排序可以这么做
- 先随机取一个数，然后将这个数放到最后，再设置两个指针left和right
- left用于找比这个数大的数，right用于找比这个数小的数
- left和right只要找到了就停止寻找，然后交换这两个数，然后再接着往下走
- 注意的是当left=right的时候，那么就把这个随机数放到这个位置。
- 接着再在左边和右边分别取随机数，重复上面的步骤，知道排序完成

**动画演示**：

![img](https://gitee.com/guoluyan53/image-bed/raw/master/img/1867034-cd65e35d7dce5045.gif)

```javascript
function quickSort(arr,left,right){
    var len = arr.length,
        partitionIndex,
        left = typeof left !='number' ? 0 : left,
        right = typeof right!='number' ? len-1 : right;
    if(left <right) {
        partitionIndex = partition(arr,left,right);
        quickSort(arr,left,partitionIndex-1);
        quickSort(arr,partitionIndex+1,right);
    }
    return arr;
}

function partition(arr,left,right){ //分区操作
    var pivot = left,
        index = pivot +1;
    for(let i=index;i<=right;i++){
        if(arr[i] < arr[pivot]){
            swap(arr,i,index);
            index++;
        }
    }
    swap(arr,pivot,index-1);
    return index-1;
}

function swap(arr,i,j){
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

