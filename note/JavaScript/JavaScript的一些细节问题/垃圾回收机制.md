> - [深入理解Chrome V8垃圾回收机制](https://mp.weixin.qq.com/s/YAvBfY7cF8WUm5XuJDoYTg)
> - [图解v8垃圾回收机制](https://juejin.cn/post/6995706341041897486)
> - [浏览器垃圾回收机制](https://blog.csdn.net/qq_20282263/article/details/88694143)
>
> 面试的时候有被问到js的垃圾回收机制，面试官突然问为什么要有这么多方法？有这么多方法肯定是因为某个方法有缺点，才会创造出新的方法。是啊，很多新的事物不就是因为旧的事物不好才会诞生的吗。所以说有对比才会有进步！！

# 垃圾回收机制

## 1. GC

GC即 Garbage Collection，程序在工作过程中会产生垃圾，这些垃圾不用的内存或者是之前用过的，以后不会再使用的内存空间，而GC就是负责回收垃圾的，因为他们在引擎工作，所以对我们前端开发来说，GC过程是相对比较无感的，这一套引擎执行而对内存处理的操作就是垃圾回收机制了。

## 2. 垃圾产生和为何回收

创建变量都是需要占有内存的。JS中引用数据类型的数据是保存在堆内存中的，栈内存中保存的一个引用。当我们给一个对象重新赋值，原对象数据就没有被引用了，也就是一个无用的对象数据，如果任由它放在内存中，这样会给内存造成负担，所以就需要被清理（回收）。

**程序运行需要内存，只要程序提出要求，操作系统或者运行环境就必须提供内存，对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则会影响性能，重则就会导致进程崩溃**。

## 3. 垃圾回收策略

在JS中内存管理有一个概念叫做 **可达性**，就是可以以某种方式访问或者可用的值，它们被存储在内存中，反之不可访问就需要回收。

那如何进行回收？JS中垃圾回收机制的原理简单来说就是定期找出那些不再使用的内存（变量），然后释放其内存。

### （1）标记清除法

改方法分为 **标记** 和 **清除**两个阶段。

- **标记阶段**：即为所有活动对象做上标记
- **清除阶段**：把没有标记（也就是非活动对象）销毁。

**【如何标记？】**

1. 当变量进入执行环境时，反转某位（通过一个二进制字符来表示标记）
2. 又或者可以维护一个进入环境变量和离开环境变量的两个列表，可以自由的把一个变量从一个列表移到另一个列表。

引擎在使用标记清除算法进行GC时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组根对象，而所谓的根对象，其实在浏览器环境中不止全局window对象、文档DOM树等。

**【标记清除发的大致过程如下】**：

1. 垃圾收集器在运行时会给内存中的所有变量加上一个标记，假设内存中所有对象都是垃圾，全标记为0
2. 然后从各个根节点对象开始遍历，把不是垃圾的节点改为1
3. 清除所有标记为0的垃圾，销毁并回收它们所占用的内存空间
4. 随后，把所有内存中标记修改为0，等待下一轮垃圾回收。

**【优缺点】**：

- **优点**：简单，打标记只有打与不大两种情况。用二进制位（0和1）就可以为其标记。
- **缺点**：清除垃圾后，剩余对象内存位置是不变的，会导致空闲的内存空间不连接，出现**内存碎片**，并且由于剩下空间内存不是一个整块，他是由不同大小的内存组成的内存列表，这就会牵扯出内存分配的问题。（而内存分配问题又有三种分配的策略，**分配速度慢**）
  - 如何解决内存碎片的问题呢？
    - 这里可以使用 **标记压缩算法（Mark-Compat）算法**：它的标记和清除算法没什么不同，只是标记清除后，标记算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。

### （2）引用计数算法

引用计数它把对象是否不再需要简化为对象，有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。目前很少使用这个方法，因为问题比较多。

**过程如下**：

1. 当声明一个变量并将其引用类型赋值给该变量的时候这个**值的引用次数**就为`1`
2. 如果**同一个值**又被赋值给另外一个变量，那么引用次数`+1`
3. 如果该变量被赋予了其他值，那么引用次数 `-1`
4. 当这个值的引用次数变为0时，则说明没有被使用了，那么这个值没法被访问，垃圾回收器会在执行的时候清理掉引用次数为0的值占用的内存。

**优点**：

- 思路相对标记清除法更清晰
- 标记清除法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程必须暂停去执行一段时间的GC，另外，标记清除算法需要遍历堆里面的所有对象，来进行后续操作。而技术只需要在引用时计数就可以了。

**缺点**：

- 需要一个计数器，而计数器需要占有很大的位置，因为我们不知道引用数量的上线
- 无法解决循环引用无法回收的问题。

## 4. V8中的GC

V8也是采用的标记清除算法，但是V8对其进行了一些优化加工处理。

V8的垃圾回收策略主要基于**分代式**垃圾回收机制，V8将内存分为**新生代**和**老生代**两个区域，采用不同的垃圾回收器也就是不同的策略进行垃圾回收。